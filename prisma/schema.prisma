// Because Prisma Client is tailored to your own schema, you need to update it every time your Prisma schema file is changing by running the following command:

// npx prisma generate

// schema.prisma file is comprised of some admin setup, generator and datasource, and data model definitions

// Data model definition includes:
// - Models: Defines fields and relationships between models
// - Enum: Blocks of type-definitions
// - Attributes and functions that change fields and models: e.g. unique, primary_key, autoincrement, etc.

// ----------------------------- //
// PRISMA CONFIG
// ***************************** //

generator client {
  provider      = "prisma-client-js"
  // Prisma client (frontend) setup
  binaryTargets = ["native", "debian-openssl-1.0.x"]
  // Prisma deploy contexts (Vercel/Netlify)
}

datasource db {
  provider = "postgresql"
  // Prisma DB type
  url      = env("DATABASE_URL")
  // Prisma DB access secret
}

// ----------------------------- //
// DATA MODEL DEFINITIONS
// ***************************** //

// Model definition components:
// FIELD NAME
// FIELD TYPE
// OPTIONAL MODIFIERS
// OPTIONAL ATTRIBUTES

// FIELD NAME DEFINITION
// camelCase
// Must start with a letter

// FIELD TYPE DEFINITION
// Field type determines its structure
// Two categories, scalar types (subcategory, enum), and model types
// - Scalar types map to columns in the database, e.g. string, int
// - Model types map to other models, and then the field is a relation field
//
//

// RELATION FIELDS
// Every relation must have exactly two relation fields, one on each model. In case of 1-1 and 1-n relations, an additional relation scalar field is required which gets linked by one of the two relation fields in the @relation attribute. This relation scalar is the direct representation of the foreign key in the underlying database.

model RelatedDemo {
  relatedDemoId Int @id // relation scalar field (used in the `@relation` attribute of Demo)

  demos Demo[]
}

model Demo {
  authorId Int @id // relation scalar field (used in the `@relation` attribute below)

  demo RelatedDemo @relation(fields: [authorId], references: [relatedDemoId])
}

//
//
//

model test {
  // Test model/table
  // A single column marked as id, with content of string
  test_table String @id
}

// Next-Auth [Accounts]
model Account {
  id                 Int       @id @default(autoincrement())
  compoundId         String    @unique @map("compound_id")
  userId             Int       @map("user_id")
  providerType       String    @map("provider_type")
  providerId         String    @map("provider_id")
  providerAccountId  String    @map("provider_account_id")
  refreshToken       String?   @map("refresh_token")
  accessToken        String?   @map("access_token")
  accessTokenExpires DateTime? @map("access_token_expires")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @default(now()) @map("updated_at")

  @@index([providerAccountId], name: "providerAccountId")
  @@index([providerId], name: "providerId")
  @@index([userId], name: "userId")
  @@map("accounts")
}

// Next-Auth [Sessions]
model Session {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  expires      DateTime
  sessionToken String   @unique @map("session_token")
  accessToken  String   @unique @map("access_token")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @map("updated_at")

  @@map("sessions")
}

// Next-Auth [Users]
model User {
  // ID --- number --- PRIMARY KEY --- defaults to db-level autoincrement/assignment
  id Int @id @default(autoincrement())

  // name --- string --- optional
  name String?

  // email --- string --- optional --- must be unique
  email String? @unique

  // userCreatedAt --- date & time --- defaults to account creation @now time --- @maps column name to PSQL preferred snake_case
  createdAt DateTime @default(now()) @map("created_at")

  // userUpdatedAt --- date & time --- prisma client sets updated time if not provided --- @maps to snake_case
  updatedAt DateTime @updatedAt @map("updated_at")

  // emailIsVerified --- date & time optional --- @maps to snake_case
  emailVerified DateTime? @map("email_verified")

  // image --- string --- optional
  image String?

  // posts fieldTYPE POST --- modifier [] makes the field a list
  // fieldName: posts
  // fieldType: postModelRelation
  // modifier[]: List
  posts Post[]

  // profile fieldTYPE Profile --- optional
  profile Profile?

  // Maps the Prisma schema model name to a table with a different name, or an enum name to a different underlying enum in the database.
  // e.g. model user to USERS table in PSQL
  @@map("users")
}

// Blog Post
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId Int
}

model Profile {
  id             Int      @id @default(autoincrement())
  createdAt      DateTime @default(now()) @map("created_at")
  authorId       Int
  user           User     @relation(fields: [authorId], references: [id])
  profilePicture String?
  bio            String?
  posts          Post[]
}
